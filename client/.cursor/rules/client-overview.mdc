---
globs: **/client/**
alwaysApply: false
---

This is the frontend, written in React and TypeScript.
This project uses TanStack Query (@tanstack/react-query) and Tailwind CSS.

## API Request Structure Guidelines

### Service Layer Pattern

All API services should follow this established pattern (see `leads.service.ts` and `organization.service.ts` as reference):

#### 1. Service File Structure (`*.service.ts`)

```typescript
import type { QueryClient } from '@tanstack/react-query'
import { authService } from './auth.service'

// Define interfaces first
export interface EntityType {
  id: string
  // ... other properties
}

export interface CreateEntityData {
  // ... create properties
}

export interface UpdateEntityData {
  // ... update properties (all optional)
}

// Centralized query keys - ALWAYS export from service
export const entityQueryKeys = {
  all: ['entities'] as const,
  lists: () => [...entityQueryKeys.all, 'list'] as const,
  list: (filters?: Record<string, any>) => [...entityQueryKeys.lists(), filters] as const,
  details: () => [...entityQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...entityQueryKeys.details(), id] as const,
}

class EntityService {
  private baseUrl = import.meta.env.VITE_API_BASE_URL + '/api'
  private queryClient: QueryClient | null = null

  constructor(queryClient?: QueryClient) {
    if (queryClient) {
      this.queryClient = queryClient
    }
  }

  // Raw fetch methods for use with useQuery (no cache management)
  async getEntities(): Promise<EntityType[]> {
    const authHeaders = await authService.getAuthHeaders()
    const response = await fetch(`${this.baseUrl}/entities`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...authHeaders,
      },
    })
    if (!response.ok) {
      throw new Error(`Failed to fetch entities: ${response.statusText}`)
    }
    return response.json()
  }

  async getEntity(id: string): Promise<EntityType> {
    const authHeaders = await authService.getAuthHeaders()
    const response = await fetch(`${this.baseUrl}/entities/${id}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...authHeaders,
      },
    })
    if (!response.ok) {
      throw new Error(`Failed to fetch entity: ${response.statusText}`)
    }
    return response.json()
  }

  // Mutation methods with cache management
  async createEntity(data: CreateEntityData): Promise<EntityType> {
    const authHeaders = await authService.getAuthHeaders()
    const response = await fetch(`${this.baseUrl}/entities`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...authHeaders,
      },
      body: JSON.stringify(data),
    })
    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.message || 'Failed to create entity')
    }
    const result = await response.json()

    // Update cache if queryClient is available
    if (this.queryClient) {
      this.queryClient.setQueryData(entityQueryKeys.detail(result.id), result)
      this.queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
    }

    return result
  }

  async updateEntity(id: string, data: UpdateEntityData): Promise<EntityType> {
    const authHeaders = await authService.getAuthHeaders()
    const response = await fetch(`${this.baseUrl}/entities/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...authHeaders,
      },
      body: JSON.stringify(data),
    })
    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.message || 'Failed to update entity')
    }
    const updatedEntity = await response.json()

    // Update cache if queryClient is available
    if (this.queryClient) {
      this.queryClient.setQueryData(entityQueryKeys.detail(id), updatedEntity)
      this.queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
    }

    return updatedEntity
  }

  async deleteEntity(id: string): Promise<void> {
    const authHeaders = await authService.getAuthHeaders()
    const response = await fetch(`${this.baseUrl}/entities/${id}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        ...authHeaders,
      },
    })
    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.message || 'Failed to delete entity')
    }

    // Update cache if queryClient is available
    if (this.queryClient) {
      this.queryClient.removeQueries({ queryKey: entityQueryKeys.detail(id) })
      this.queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
    }
  }
}

// Singleton pattern - REQUIRED
let entityServiceInstance: EntityService | null = null

export const createEntityService = (queryClient: QueryClient): EntityService => {
  if (!entityServiceInstance) {
    entityServiceInstance = new EntityService(queryClient)
  }
  return entityServiceInstance
}

export const getEntityService = (): EntityService => {
  if (!entityServiceInstance) {
    throw new Error('EntityService not initialized. Call createEntityService() first.')
  }
  return entityServiceInstance
}

// Legacy export for backward compatibility
export const entityService = new EntityService()
```

#### 2. Query Hook File Structure (`use*Query.ts`)

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { 
  entityService, 
  entityQueryKeys,
  type EntityType,
  type CreateEntityData,
  type UpdateEntityData,
} from '../services/entity.service'

// Import query keys from service - NEVER define locally

export function useEntities() {
  return useQuery({
    queryKey: entityQueryKeys.list(),
    queryFn: () => entityService.getEntities(),
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

export function useEntity(id: string) {
  return useQuery({
    queryKey: entityQueryKeys.detail(id),
    queryFn: () => entityService.getEntity(id),
    enabled: !!id,
    staleTime: 1000 * 60 * 5,
  })
}

export function useCreateEntity() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (data: CreateEntityData) => entityService.createEntity(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
    },
  })
}

export function useUpdateEntity() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateEntityData }) =>
      entityService.updateEntity(id, data),
    onSuccess: (updatedEntity) => {
      queryClient.setQueryData(entityQueryKeys.detail(updatedEntity.id), updatedEntity)
      queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
    },
  })
}

export function useDeleteEntity() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (id: string) => entityService.deleteEntity(id),
    onSuccess: (_, id) => {
      queryClient.removeQueries({ queryKey: entityQueryKeys.detail(id) })
      queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
    },
  })
}
```

### Key Requirements

1. **ALWAYS use authService.getAuthHeaders()** for authenticated requests
2. **Export query keys from service files**, not from hook files
3. **Use singleton pattern** with createService() and getService() functions
4. **Include QueryClient integration** in service constructors
5. **Handle cache management** in mutation methods when queryClient is available
6. **Maintain backward compatibility** with legacy service exports
7. **Use consistent error handling** with try/catch and meaningful error messages
8. **Follow naming conventions**: `entityService`, `entityQueryKeys`, `useEntity*`
9. **Import types explicitly** using `type` keyword for interfaces
10. **Handle loading states** and error states consistently in components

### Authentication Headers Pattern

```typescript
const authHeaders = await authService.getAuthHeaders()
```

### API Base URL Pattern

```typescript
private baseUrl = import.meta.env.VITE_API_BASE_URL + '/api'
```

### Error Handling Pattern

```typescript
if (!response.ok) {
  const errorData = await response.json()
  throw new Error(errorData.message || 'Failed to perform operation')
}
```

### Cache Management Pattern

```typescript
// After successful mutations
if (this.queryClient) {
  this.queryClient.setQueryData(entityQueryKeys.detail(id), updatedData)
  this.queryClient.invalidateQueries({ queryKey: entityQueryKeys.lists() })
}
```